## 9.1物理和虚拟寻址
- 物理寻址(PA)：cpu向主存发送有效物理地址获取数据。
- 虚拟寻址(VA)：cpu生成虚拟地址，然后通过cpu上的内存管理单元(MMU)查询主存里面的查询表来翻译虚拟地址，查询表由操作系统管理。

## 9.3虚拟内存作为缓存的工具
虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每个字节都有一个唯一的虚拟的地址，作为到数组的指引。磁盘上的内容被缓存在主存中。磁盘上的数据被分割成块，作为磁盘和主存之间的传输单元。

VM系统将虚拟内存分割为虚拟页(Virtual Page,VP)的大小的固定的块，物理内存也被分割为物理页，大小也为P字节，物理页被称为页帧。

### 9.3.2 页表
页表将虚拟页映射到物理页。页表，是页表条目PTE组成的数组。PTE由一个有效位和一个n位地址字段组成。

## 9.4 虚拟内存作为内存管理的工具
操作系统为每个进程提供了一个独立的页表。多个虚拟页面可以映射到同一个共享物理页面上。

## 9.6 地址翻译
符号|描述
---|---
N=2^n|虚拟地址空间中的地址数量
M=2^m|物理地址空间中的地址数量
P=2^p|页的大小
VPO|虚拟页面偏移量
VPN|虚拟页号
TLBI|TLB所以
TLBt|TLB标记
PPO|物理页面偏移量
PPN|物理页号
CO|缓冲块内的字节偏移量
CI|高速缓存索引
CT|高速缓存标记

### 地址翻译过程
- 页表基址寄存器(Page Table Base Register)指向当前页表。
- n位的虚拟地址包含两个部分，p位的虚拟页面偏移(vpo),n-p位的虚拟页号(vpn)
- mmu使用vpn来选择适当的pte
- 将pte中的物理页号ppn和虚拟地址中的vpo串联起来，就得到物理地址，注意到ppo=vpo

![image](https://raw.githubusercontent.com/Jiangxiaochen/pic/master/cs-app/9-12.png)

### 9.6.3 多级页表
假设有32位的地址空间，4KB的页面和一个4字节的PTE，那么即使应用所引用的只是虚拟地址空间中很小的一部分，也总是需要一个4MB的页表驻留在内存中。(4G内存，1M个页面，因此4MB)。

## 9.7 案例研究：Intel Core i7/Linux 内存系统

### 9.7.2 Linux虚拟内存系统

#### 1.虚拟内存区域
Linux将虚拟内存组织成为一些区域的集合，一个区域就是已分配的虚拟内存的连续片，这些页以某种方式相关联。

区域的概念很重要，因为它允许虚拟地址空间有间隙。内核为系统中的每个进程维护一个单独的任务结构

## 9.8 内存映射
虚拟内存区域和一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射。可以映射两种文件：
- Linux系统中的普通文件。
- 匿名文件。这是由内核创建的，都是二进制0.直接用二进制0覆盖牺牲页面，没有实际的数据传送。

一旦一个虚拟页面被初始化，就在一个由内核维护的专门的交换文件之间换来换去。。

```
#include <unistd.h>
#include <sys/mman.h>

void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
```
## 9.9 动态内存分配
```
#include <stdlib.h>
void *malloc(size_t size);
```
这个块会为可能包含在这个块内的任何对象类型作对齐。这依赖于32位模式还是64位模式,-m32 -m64，地址分别为8和16的倍数。brk指针指向堆顶。

### 9.9.4 碎片
内部碎片，已分配块比有效载荷大。外部碎片，空闲足够但是没有连在一起，放不下对象。


- 最大化内存使用率

### 9.9.5 实现问题
- 空闲快组织
- 放置
- 分割
- 合并

### 9.10.1 垃圾收集器的基本知识
垃圾收集器将内存视为一张有向可达图。节点分为根节点和堆节点。根节点对应于不在堆中的位置，包含指向堆的指针。不可达节点对应于垃圾。

java对应用创建使用指针控制很严格，因此可以精确表示，回收所有垃圾。但是c不行，这样的收集器也称为保守的垃圾收集器。有一些不可达节点可能被标记为可达。

## 9.11 C常见内存错误
### 间接引用坏指针
```
int a = 10;
int *ptr_a = &a;
scanf("%d", ptr_a);
printf("%d\n", a);
return 0;
```
### 读取未初始化的内存
bss内存位置（未初始化的全局变量）总是被加载器初始化为0.但是堆内存不是的。
```

```




### 练习题
#### 9.1
虚拟地址位数|虚拟地址数|最大可能的虚拟地址
---|---|---
8|256|255
16|64K|64K-1
32|4G|4G-1
48|256T|256T-1
64|16E|16E-1

#### 9.2
n|P=2^p|PTE数量
---|---|---
16|4k|16
16|8k|8
32|4k|1M
32|8k|512K

### 9.3 (32位虚拟地址和24位物理地址)

P|VPN位数|VPO位数|PPN位数|PPO位数
---|---|---|---|---
1KB|22|10|14|10
2KB|21|11|13|11
4KB|20|12|12|12
8KB|19|13|11|13

### 9.4 (虚拟地址0x03d7)

#### 虚拟地址格式
00001111010111
#### 地址翻译
- P=64，p=6，因此低6位是vpo，高8位是vpn
- TLB为4组，所以TLBI为vpn的低2位，高6位作为TLBT
- L1高速缓存是物理寻址，直接映射的，行大小4字节，总共16个组。所以低2位作为块偏移(CO),接下来4位表示CI,剩下的6位表示CT

参数|值
---|---
VPN|00001111(0x0f)
TLBI|11(0x03)
TLBT|000011(0x03)
TLB命中？|是
缺页？|否
PPN|0x0d

#### 物理地址格式
(110100010111)0x0d17

#### 物理内存引用

参数|值
---|---
字节偏移|11(0x03)
缓存索引|0101(0x05)
缓存标记|110100(0x34)
缓存命中|否
返回的缓存字节|--

### 9.5
```
int main(int argc, char const *argv[])
{
	const char *file = argv[1];
	int fd = open(file,O_RDONLY);
	printf("%d\n", fd);
	struct stat st;
	fstat(fd, &st);
	void *bufp = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
	write(STDOUT_FILENO,bufp,st.st_size);
	//fflush(stdout);
	return 0;
}
```
### 9.6 双字对齐，一个字是4字节
请求|块大小|块头部
---|---|---
malloc(1)|8|0x00000009
malloc(5)|16|0x00000011
malloc(12)|16|0x00000011
malloc(13)|24|0x00000019

### 9.7
对齐要求|已分配的块|空闲块|最小块大小
---|---|---|---
单字|头部和脚部|头部和脚部|12
单字|头部|头部和脚部|8
双字|头部和脚部|头部和脚部|16
双字|头部|头部和脚部|8